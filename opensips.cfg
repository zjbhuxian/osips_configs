#
# OpenSIPS residential configuration script
#     by OpenSIPS Solutions <team@opensips-solutions.com>
#
# This script was generated via "make menuconfig", from
#   the "Residential" scenario.
# You can enable / disable more features / functionalities by
#   re-generating the scenario with different options.#
#
# Please refer to the Core CookBook at:
#      http://www.opensips.org/Resources/DocsCookbooks
# for a explanation of possible statements, functions and parameters.
#


####### Global Parameters #########

log_level=5
log_stderror=no
log_facility=LOG_LOCAL0

children=4

/* uncomment the following lines to enable debugging */
#debug_mode=yes

/* uncomment the next line to enable the auto temporary blacklisting of 
   not available destinations (default disabled) */
#disable_dns_blacklist=no

/* uncomment the next line to enable IPv6 lookup after IPv4 dns 
   lookup failures (default disabled) */
#dns_try_ipv6=yes

/* comment the next line to enable the auto discovery of local aliases
   based on reverse DNS on IPs */
auto_aliases=no


listen=udp:192.168.31.130:5060   # CUSTOMIZE ME


####### Modules Section ########

#set module path
mpath="/usr/local/opensips//lib64/opensips/modules/"

#### db_cache for storing/fetching sip info <++
loadmodule "db_cache.so"
modparam("db_cache", "redis_host", "192.168.31.128")
modparam("db_cache", "redis_auth", "redispass")
modparam("db_cache", "redis_port", 6379) 
modparam("db_cache", "redis_timeout", 300)
modparam("db_cache", "redis_max_socks", 30)
modparam("db_cache", "redis_rwtimeout", 2000)
modparam("db_cache", "redis_retry_delay", 1)


#### SIGNALING module
loadmodule "signaling.so"

#### StateLess module
loadmodule "sl.so"

#### Record Route Module
loadmodule "rr.so"
/* do not append from tag to the RR (no need for this script) */
modparam("rr", "append_fromtag", 0)

#### MAX ForWarD module
loadmodule "maxfwd.so"

#### SIP MSG OPerationS module
loadmodule "sipmsgops.so"

#### textops module <++
loadmodule "textops.so"

#### AVPOPS module <++
loadmodule "avpops.so"

#### Mysql module <++
loadmodule "db_mysql.so"

#### Dispatcher module <++
loadmodule "dispatcher.so"
modparam("dispatcher", "db_url", "mysql://root:root@192.168.31.128/opensips")
modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_probing_mode", 0)

#### FIFO Management Interface
loadmodule "mi_fifo.so"
modparam("mi_fifo", "fifo_name", "/tmp/opensips_fifo")
modparam("mi_fifo", "fifo_mode", 0666)

#### URI module
loadmodule "uri.so"
modparam("uri", "use_uri_table", 0)

#### USeR LOCation module
loadmodule "usrloc.so"
modparam("usrloc", "nat_bflag", "NAT")
modparam("usrloc", "working_mode_preset", "single-instance-no-db")

#### REGISTRAR module
loadmodule "registrar.so"
modparam("registrar", "tcp_persistent_flag", "TCP_PERSISTENT")
/* uncomment the next line not to allow more than 10 contacts per AOR */
#modparam("registrar", "max_contacts", 10)

loadmodule "proto_udp.so"
#loadmodule "proto_hep.so" #<++

#### Sipcapture module <++
loadmodule "sipcapture.so"
modparam("sipcapture", "db_url", "mysql://root:root@192.168.31.128/opensips")
modparam("sipcapture", "table_name", "homer_capture")
modparam("sipcapture", "capture_on", 1)
##### configuration for Mirroring PORT
modparam("sipcapture", "raw_socket_listen", "192.168.31.130:5060")
modparam("sipcapture", "raw_interface", "ens33")
##### activate HEP capturing <++
#modparam("sipcapture", "hep_capture_on", 1)
##### activate monitoring port capturing
#modparam("sipcapture", "raw_moni_capture_on", 1)
#modparam("sipcapture", "raw_sock_children", 2)
modparam("sipcapture", "raw_ipip_capture_on", 1)
modparam("sipcapture", "promiscious_on", 1)


####### Routing Logic ########

# main request routing logic

route{
	if (!mf_process_maxfwd_header("10")) {
		send_reply("483","Too Many Hops");
		exit;
	}

	#zhou++ >>>>>>>
	if(is_method("OPTIONS")){
		send_reply("200", "ok");
		exit;
	}

	if(!is_method("OPTIONS|NOTIFY")){
		#sip_capture();
	}

	$var(local_ip)="192.168.31.130";
	if(!ds_is_in_list("$si", "$sp")){
		xlog("L_INFO", ">>>TRACE: OUTSIDE REQUEST [$mb] From [$si:$sp]\n");
		if(is_method("INVITE")){
			sip_capture(); #for test >>>>
			route(follow_from_out);
			$var(new_du)=$du;
			$var(new_ip_port)=$(var(new_du){s.substr,4,0});
			store_info("$ci", "invite", "du_ip", "$var(new_ip_port)"); #temp
			record_route_preset("$var(local_ip)"); 
			forward();
			sip_capture(); #for test <<<<
		}

		if(is_method("CANCEL")){
			route(follow_from_out);
		}

		if(is_method("ACK")){
			route(follow_from_out);
		}

		if(is_method("BYE")){
			route(follow_from_out);
		}

		forward();
	}else{
		xlog("L_INFO", ">>>TRACE: INSIDE REQUEST [$mb] From [$si:$sp]\n");
		if(is_method("INVITE")){
			$var(src_callid)="";
			if(is_present_hf("X-SRC-CALLID")){
				$var(src_callid)=$(hdr(X-SRC-CALLID));
				xlog("L_INFO", ">>>DBG: header field [X-SRC-CALLID] = [$var(src_callid)]\n");
				store_callid("$ci", "$var(src_callid)");
				store_callid("$var(src_callid)", "$ci");
			}
			if(!loose_route()){
				xlog("L_INFO", ">>>DBG: Failed to loose_route()...\n");
				send_reply("500", "No Route,Give me Route!");
				exit;
			}
			store_info("$ci", "invite", "du", "$du");
			record_route_preset("$var(local_ip)");
			forward();
		}

		if(is_method("CANCEL")){
			route(follow_from_in);
			forward();
		}

		if(is_method("ACK")){
			route(follow_from_in);
			forward();
		}
		
		if(is_method("BYE")){
			route(follow_from_in);
			forward();
		}
	}
	#zhou++ <<<<<<<

	if (has_totag()) {

		# handle hop-by-hop ACK (no routing required)
		# zhou-- >>>>
		#if ( is_method("ACK") && t_check_trans() ) {
		#	t_relay();
		#	exit;
		#}
		# zhou-- <<<<

		# sequential request within a dialog should
		# take the path determined by record-routing
		if ( !loose_route() ) {
			# we do record-routing for all our traffic, so we should not
			# receive any sequential requests without Route hdr.
			send_reply("404","Not here");
			exit;
		}

		if (is_method("BYE")) {
			# do accounting even if the transaction fails
			#do_accounting("log","failed"); zhou-- <<<
		}

		# route it out to whatever destination was set by loose_route()
		# in $du (destination URI).
		route(relay);
		exit;
	}

	# absorb retransmissions, but do not create transaction
	#t_check_trans(); #zhou--

	if ( !(is_method("REGISTER")  ) ) {
		
		if (is_myself("$fd")) {
					
		} else {
			# if caller is not local, then called number must be local
			
			if (!is_myself("$rd")) {
				send_reply("403","Relay Forbidden");
				exit;
			}
		}

	}

	# preloaded route checking
	# zhou-->>>>
	#if (loose_route()) {
	#	xlog("L_INFO", ">>>!!!! [$mb]\n");#<++ zhou
	#	xlog("L_ERR",
	#		"Attempt to route with preloaded Route's [$fu/$tu/$ru/$ci]");
	#	if (!is_method("ACK"))
	#		send_reply("403","Preload Route denied");
	#	exit;
	#}
	# zhou--<<<<<

	# record routing
	# zhou-- >>>>
	#if (!is_method("REGISTER|MESSAGE"))
		#record_route();
	# zhou-- <<<<

	# account only INVITEs
	if (is_method("INVITE")) {
		
		#do_accounting("log"); zhou-- <<<
	}

	
	if (!is_myself("$rd")) {
		append_hf("P-hint: outbound\r\n"); 
		
		route(relay);
	}

	# requests for my domain
	
	if (is_method("PUBLISH|SUBSCRIBE")) {
		send_reply("503", "Service Unavailable");
		exit;
	}

	if (is_method("REGISTER")) {
				
		if (!save("location"))
			sl_reply_error();

		exit;
	}

	if ($rU==NULL) {
		# request with no Username in RURI
		send_reply("484","Address Incomplete");
		exit;
	}

	# do lookup with method filtering
	# zhou-- >>>>
	#if (!lookup("location","m")) {
	#	t_reply("404", "Not Found");
	#	exit;
	#} zhou-- <<<<

	# when routing via usrloc, log the missed calls also
	#do_accounting("log","missed");zhou--
	route(relay);
}


route[relay] {
	# for INVITEs enable some additional helper routes
	if (is_method("INVITE")) {
		# zhou-- >>>
		#t_on_branch("per_branch_ops");
		#t_on_reply("handle_nat");
		#t_on_failure("missed_call");
		# zhou-- <<<<
	}

	# zhou-- >>>>
	#if (!t_relay()) {
	#	send_reply("500","Internal Error");
	#}
	# zhou-- <<<<<
	exit;
}

route[dispatcher] {
	if(ds_select_dst("100", "0")){
		xlog("L_INFO", ">>>DBG: Got new destination [$du] by dispatcher\n");
	}else{
		xlog("L_INFO", ">>>ERR: Failed to get destination by dispatcher\n");
		send_reply("500", "Service full(Got no destination)");
		exit;
	}
}

route[follow_from_out]{
	if(!loose_route()){
		xlog("L_INFO", ">>>DBG: From outside[$si:$sp], no route preset, so try dispatcher\n");
		route(dispatcher);
	}else{
		xlog("L_INFO", ">>>DBG: From outside[$si:$sp], routed by route preset\n");
	}
}

route[follow_from_in]{
	if(!loose_route()){
		xlog("L_INFO", ">>>DBG: From inside[$si:$sp], no route preset, so try cache info\n");
		$var(new_du)="";
		fetch_info("$ci", "invite", "du", "$var(new_du)");
		$du=$var(new_du);
		xlog("L_INFO", ">>>DBG: Fetched du [$var(new_du)] from cache by callid [$ci]\n");
	}else{
		xlog("L_INFO", ">>>DBG: From inside[$si:$sp], routed by route preset\n");
	}
}

#onreply_route{
	#sip_capture();
#}

#branch_route[per_branch_ops] {
#	xlog("new branch at $ru\n");
#}
#
#
#onreply_route[handle_nat] {
#	xlog("incoming reply\n");
#}
#
#
#failure_route[missed_call] {
#	# zhou-- >>>>
#	#if (t_was_cancelled()) {
#	#	exit;
#	#}
#	# zhou-- <<<<
#
#	# uncomment the following lines if you want to block client 
#	# redirect based on 3xx replies.
#	##if (t_check_status("3[0-9][0-9]")) {
#	##t_reply("404","Not found");
#	##	exit;
#	##}
#
#	
#}



