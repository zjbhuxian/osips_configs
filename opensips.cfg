#
# OpenSIPS residential configuration script
#     by OpenSIPS Solutions <team@opensips-solutions.com>
#
# This script was generated via "make menuconfig", from
#   the "Residential" scenario.
# You can enable / disable more features / functionalities by
#   re-generating the scenario with different options.#
#
# Please refer to the Core CookBook at:
#      http://www.opensips.org/Resources/DocsCookbooks
# for a explanation of possible statements, functions and parameters.
#


####### Global Parameters #########

log_level=5
log_stderror=no
log_facility=LOG_LOCAL0

children=4

/* uncomment the following lines to enable debugging */
#debug_mode=yes

/* uncomment the next line to enable the auto temporary blacklisting of 
   not available destinations (default disabled) */
#disable_dns_blacklist=no

/* uncomment the next line to enable IPv6 lookup after IPv4 dns 
   lookup failures (default disabled) */
#dns_try_ipv6=yes

/* comment the next line to enable the auto discovery of local aliases
   based on reverse DNS on IPs */
auto_aliases=no


#listen=udp:192.168.20.91:5060   # CUSTOMIZE ME
listen=udp:192.168.253.57:5060


####### Modules Section ########

#set module path
mpath="/usr/local/opensips//lib64/opensips/modules/"

#### db_cache for storing/fetching sip info <++
loadmodule "db_cache.so"
modparam("db_cache", "redis_host", "192.168.13.143")
modparam("db_cache", "redis_auth", "helloredis")
modparam("db_cache", "redis_port", 9737) 
modparam("db_cache", "redis_timeout", 200)
modparam("db_cache", "redis_max_socks", 40)
modparam("db_cache", "redis_rwtimeout", 3000)
modparam("db_cache", "redis_retry_delay", 1)


#### SIGNALING module
loadmodule "signaling.so"

#### StateLess module
loadmodule "sl.so"

#### Transaction module <++ statefull
loadmodule "tm.so"

#### Record Route Module
loadmodule "rr.so"
/* do not append from tag to the RR (no need for this script) */
modparam("rr", "append_fromtag", 0)

#### MAX ForWarD module
loadmodule "maxfwd.so"

#### SIP MSG OPerationS module
loadmodule "sipmsgops.so"

#### textops module <++
loadmodule "textops.so"

#### uac module <++ uac_replace_xxx
loadmodule "uac.so"
modparam("uac", "restore_mode", "manual")

#### AVPOPS module <++
loadmodule "avpops.so"

#### Mysql module <++
loadmodule "db_mysql.so"

#### Dispatcher module <++
loadmodule "dispatcher.so"
modparam("dispatcher", "db_url", "mysql://opensips:opensipsrw@192.168.253.61/opensips")
modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_probing_mode", 0)

#### FIFO Management Interface
loadmodule "mi_fifo.so"
modparam("mi_fifo", "fifo_name", "/tmp/opensips_fifo")
modparam("mi_fifo", "fifo_mode", 0666)

#### URI module
loadmodule "uri.so"
modparam("uri", "use_uri_table", 0)

#### USeR LOCation module
loadmodule "usrloc.so"
modparam("usrloc", "nat_bflag", "NAT")
modparam("usrloc", "working_mode_preset", "single-instance-no-db")

#### REGISTRAR module
loadmodule "registrar.so"
modparam("registrar", "tcp_persistent_flag", "TCP_PERSISTENT")
/* uncomment the next line not to allow more than 10 contacts per AOR */
#modparam("registrar", "max_contacts", 10)

loadmodule "proto_udp.so"
#loadmodule "proto_hep.so" #<++

##### Sipcapture module <++
#loadmodule "sipcapture.so"
#modparam("sipcapture", "db_url", "mysql://root:root@192.168.31.128/opensips")
#modparam("sipcapture", "table_name", "homer_capture")
#modparam("sipcapture", "capture_on", 1)
###### configuration for Mirroring PORT
#modparam("sipcapture", "raw_socket_listen", "192.168.31.130:5060")
#modparam("sipcapture", "raw_interface", "ens33")
###### activate HEP capturing <++
##modparam("sipcapture", "hep_capture_on", 1)
###### activate monitoring port capturing
##modparam("sipcapture", "raw_moni_capture_on", 1)
##modparam("sipcapture", "raw_sock_children", 2)
#modparam("sipcapture", "raw_ipip_capture_on", 1)
#modparam("sipcapture", "promiscious_on", 1)


####### Routing Logic ########

# main request routing logic

route{
	if (!mf_process_maxfwd_header("10")) {
		send_reply("483","Too Many Hops");
		exit;
	}

	#zhou++ >>>>>>>
	if(is_method("OPTIONS")){
		send_reply("200", "ok");
		exit;
	}

	if(!is_method("OPTIONS|NOTIFY")){
		#sip_capture();
	}

	$var(local_ip)="192.168.253.57";
	if(!ds_is_in_list("$si", "$sp")){
		xlog("L_INFO", ">>>TRACE: OUTSIDE REQUEST [$mb] From [$si:$sp]\n");
		if(is_method("INVITE")){
			#sip_capture(); #for test >>>>
			route(follow_from_out);
			route(invite_from_out_business);
			record_route_preset("$var(local_ip)"); 
			forward();
			#sip_capture(); #for test <<<<
		}

		if(is_method("CANCEL")){
			route(follow_from_out);
			forward();
		}

		if(is_method("ACK")){
			route(follow_from_out);
			forward();
		}

		if(is_method("PRACK")){
			route(follow_from_out);
			forward();
		}

		if(is_method("BYE")){
			route(follow_from_out);
			forward();
		}
	}else{
		xlog("L_INFO", ">>>TRACE: INSIDE REQUEST [$mb] From [$si:$sp]\n");
		if(is_method("INVITE")){
			#$var(src_callid)="";
			#if(is_present_hf("X-SRC-CALLID")){
			#	$var(src_callid)=$(hdr(X-SRC-CALLID));
			#	xlog("L_INFO", ">>>DBG: header field [X-SRC-CALLID] = [$var(src_callid)]\n");
			#	store_callid("$ci", "$var(src_callid)");
			#	store_callid("$var(src_callid)", "$ci");
			#}
			route(invite_from_in_business);
			if(!loose_route()){
				xlog("L_INFO", ">>>DBG: Failed to loose_route()...\n");
				send_reply("500", "No Route,Give me Route!");
				exit;
			}
			store_info("$ci", "invite", "du", "$du");
			record_route_preset("$var(local_ip)");
			forward();
		}

		if(is_method("CANCEL")){
			route(follow_from_in);
			forward();
		}

		if(is_method("ACK")){
			route(follow_from_in);
			forward();
		}

		if(is_method("PRACK")){
			route(follow_from_in);
			forward();
		}
		
		if(is_method("BYE")){
			route(follow_from_in);
			forward();
		}
	}
	#zhou++ <<<<<<<

	if (has_totag()) {

		# handle hop-by-hop ACK (no routing required)
		# zhou-- >>>>
		#if ( is_method("ACK") && t_check_trans() ) {
		#	t_relay();
		#	exit;
		#}
		# zhou-- <<<<

		# sequential request within a dialog should
		# take the path determined by record-routing
		if ( !loose_route() ) {
			# we do record-routing for all our traffic, so we should not
			# receive any sequential requests without Route hdr.
			send_reply("404","Not here");
			exit;
		}

		if (is_method("BYE")) {
			# do accounting even if the transaction fails
			#do_accounting("log","failed"); zhou-- <<<
		}

		# route it out to whatever destination was set by loose_route()
		# in $du (destination URI).
		route(relay);
		exit;
	}

	# absorb retransmissions, but do not create transaction
	#t_check_trans(); #zhou--

	#if ( !(is_method("REGISTER")  ) ) {
	#	
	#	if (is_myself("$fd")) {
	#				
	#	} else {
	#		# if caller is not local, then called number must be local
	#		
	#		if (!is_myself("$rd")) {
	#			send_reply("403","Relay Forbidden");
	#			exit;
	#		}
	#	}

	#}

	# preloaded route checking
	# zhou-->>>>
	#if (loose_route()) {
	#	xlog("L_INFO", ">>>!!!! [$mb]\n");#<++ zhou
	#	xlog("L_ERR",
	#		"Attempt to route with preloaded Route's [$fu/$tu/$ru/$ci]");
	#	if (!is_method("ACK"))
	#		send_reply("403","Preload Route denied");
	#	exit;
	#}
	# zhou--<<<<<

	# record routing
	# zhou-- >>>>
	#if (!is_method("REGISTER|MESSAGE"))
		#record_route();
	# zhou-- <<<<

	# account only INVITEs
	if (is_method("INVITE")) {
		
		#do_accounting("log"); zhou-- <<<
	}

	
	if (!is_myself("$rd")) {
		append_hf("P-hint: outbound\r\n"); 
		
		route(relay);
	}

	# requests for my domain
	
	if (is_method("PUBLISH|SUBSCRIBE")) {
		send_reply("503", "Service Unavailable");
		exit;
	}

	if (is_method("REGISTER")) {
				
		if (!save("location"))
			sl_reply_error();

		exit;
	}

	if ($rU==NULL) {
		# request with no Username in RURI
		send_reply("484","Address Incomplete");
		exit;
	}

	# do lookup with method filtering
	# zhou-- >>>>
	#if (!lookup("location","m")) {
	#	t_reply("404", "Not Found");
	#	exit;
	#} zhou-- <<<<

	# when routing via usrloc, log the missed calls also
	#do_accounting("log","missed");zhou--
	route(relay);
}


route[relay] {
	# for INVITEs enable some additional helper routes
	if (is_method("INVITE")) {
		# zhou-- >>>
		#t_on_branch("per_branch_ops");
		#t_on_reply("handle_nat");
		#t_on_failure("missed_call");
		# zhou-- <<<<
	}

	# zhou-- >>>>
	#if (!t_relay()) {
	#	send_reply("500","Internal Error");
	#}
	# zhou-- <<<<<
	exit;
}

route[dispatcher] {
	if(ds_select_dst("100", "0")){
		xlog("L_INFO", ">>>DBG: Got new destination [$du] by dispatcher\n");
	}else{
		xlog("L_INFO", ">>>ERR: Failed to get destination by dispatcher\n");
		send_reply("500", "Service full(Got no destination)");
		exit;
	}
}

route[follow_from_out]{
	if(!loose_route()){
		xlog("L_INFO", ">>>DBG: From outside[$si:$sp], no route preset, so try dispatcher\n");
		route(dispatcher);
	}else{
		xlog("L_INFO", ">>>DBG: From outside[$si:$sp], routed by route preset\n");
	}
}

route[follow_from_in]{
	if(!loose_route()){
		xlog("L_INFO", ">>>DBG: From inside[$si:$sp], no route preset, so try cache info\n");
		$var(new_du)="";
		fetch_info("$ci", "invite", "du", "$var(new_du)");
		$du=$var(new_du);
		xlog("L_INFO", ">>>DBG: Fetched du [$var(new_du)] from cache by callid [$ci]\n");
	}else{
		xlog("L_INFO", ">>>DBG: From inside[$si:$sp], routed by route preset\n");
	}
}

route[invite_from_out_business]{
	xlog("L_DBG", ">>>DBG: Entered invite_from_out_business\n");
	$var(new_du)=$du;
	$var(new_ip_port)=$(var(new_du){s.substr,4,0});
	# Request-User
	xlog("L_DBG", ">>>DBG: cache the request-user [$rU]\n");
	store_info("$ci", "invite", "ruser", "$rU");
	# From-Uri 
	xlog("L_DBG", ">>>DBG: cache the From-uri [$fu]\n");
	store_info("$ci", "invite", "from", "$fu");
	# To-Uri
	xlog("L_DBG", ">>>DBG: cache the To-uri [$tu]\n");
	store_info("$ci", "invite", "to", "$tu");
	# Route
	if(is_present_hf("Route")){
		$var(r_cnt)=0;
		for($var(r_index) in $(hdr(Route)[*])){
			$var(r_cnt)=$var(r_cnt)+1;
			$var(r_route_idx)="";
			$var(r_route_tmp)="";
			$var(i)=0;
			$var(r_index_idx)=$(var(r_index){s.select,$var(i),,});
			while($(var(r_index_idx){s.len}) > 0){
				xlog("L_DBG", ">>>DBG: r_index_idx = [$var(r_index_idx)]\n");
				if($var(r_index_idx)!~"^<sip:nlkfSCPajc.[z|b]j.bj.bj.ims.mnc011.mcc460.*>$"){
					xlog("L_DBG", ">>>DBG: NOT local domain route...\n");
					if($(var(r_route_tmp){s.len}) == 0)
						$var(r_route_tmp)=$var(r_index_idx);
					else
						$var(r_route_tmp)=$var(r_route_tmp)+","+$var(r_index_idx);
				}else{
					xlog("L_DBG", ">>>DBG: IS local domain route...\n");
				}
				$var(i)=$var(i)+1;
				$var(r_index_idx)=$(var(r_index){s.select,$var(i),,});
			}
			$var(r_route)=$(var(r_route_tmp){s.encode.hexa})+":"+$var(r_route);
			xlog("L_DBG", ">>>DBG: invite with route [$var(r_index)]\n");
		}
		$var(r_route)=$var(r_route)+$var(r_cnt);
		xlog("L_DBG", ">>>DBG: invite with [$var(r_cnt)] routes\n");
		xlog("L_DBG", ">>>DBG: cache the route [$var(r_route)]\n");
		store_info("$ci", "invite", "route", "$var(r_route)");
	}
	# PANI
	$var(r_pani)="";
	if(is_present_hf("P-Access-Network-Info")){
		xlog("L_DBG", ">>>DBG: cache the request-user [$rU]\n");
		$var(r_pani)=$(hdr(P-Access-Network-Info));
		store_info("$ci", "invite", "pani", "$var(r_pani)");
	}
	# PAI
	$var(r_pai)="";
	if(is_present_hf("P-Asserted-Identity")){
		xlog("L_DBG", ">>>DBG: cache the request-user [$rU]\n");
		$var(r_pai)=$(hdr(P-Asserted-Identity));
		store_info("$ci", "invite", "pai", "$var(r_pai)");
	}
	# fix request-uri
	$var(rU_new)=$rU;
	if($var(rU_new)=~"^\+86.*"){
		xlog("L_DBG", ">>>DBG: Request User with [+86]\n");
		$var(rU_new)=$(var(rU_new){s.substr,3,0});
		if(!($var(rU_new)=~"^0?1[3456789][0-9]{9}$")){
			xlog("L_DBG", ">>>DBG: Not Phone-number, headered with 0\n");
			$var(rU_new)="0"+$var(rU_new);
		}
		xlog("L_DBG", ">>>DBG: Fixed request-User is [$var(rU_new)]\n");
	}
	if($ru=~"^tel:.*"){
		xlog("L_DBG", ">>>DBG: Tel Format [$ru], from [$si:$sp]\n");
	}else if($ru=~"^sip:.*@.*"){
		xlog("L_DBG", ">>>DBG: Sip Format [$ru], from [$si:$sp]\n");
	}
	$ru="sip:"+$var(rU_new)+"@"+$var(new_ip_port);
	xlog("L_DBG", ">>>DBG: New Request-Uri is [$ru]\n");
	# fix from-uri
	$var(changed_fU)=0;
	$var(fU_new)=$fU;
	if($var(fU_new)=~"^\+86.*"){
		$var(changed_fU)=1;
		$var(fU_new)=$(var(fU_new){s.substr,3,0});
		if(!($var(fU_new)=~"^0?1[3456789][0-9]{9}$")){
			xlog("L_DBG", ">>>DBG: From User Not Phone-number, headered with 0\n");
			$var(fU_new)="0"+$var(fU_new);
		}
		xlog("L_DBG", ">>>DBG: Fixed From User is [$var(fU_new)]\n");
	}
	if(($fu=~"^tel:.*") || ($var(changed_fU) == 1)){
		$var(new_from)="sip:"+$var(fU_new)+"@"+$var(new_ip_port);
		uac_replace_from("", "$var(new_from)");
	}
	# fix to-uri
	$var(changed_tU)=0;
	$var(tU_new)=$tU;
	if($var(tU_new)=~"^\+86.*"){
		$var(changed_tU)=1;
		$var(tU_new)=$(var(tU_new){s.substr,3,0});
		if(!($var(tU_new)=~"^0?1[3456789][0-9]{9}$")){
			xlog("L_DBG", ">>>DBG: To User Not Phone-number, headered with 0\n");
			$var(tU_new)="0"+$var(tU_new);
		}
		xlog("L_DBG", ">>>DBG: Fixed To User is [$var(tU_new)]\n");
	}
	if(($tu=~"^tel:.*") || ($var(changed_tU) == 1)){
		$var(new_to)="sip:"+$var(tU_new)+"@"+$var(tmp_domain);
		uac_replace_to("", "$var(new_to)");
	}
	# Header handle
	append_hf("X-RECORD-SRCDST: $si:$sp\r\n");
	append_hf("X-RECORD-SRCIP: $var(local_ip)\r\n");
}

route[invite_from_in_business]{
	xlog("L_DBG", ">>>DBG: Entered invite_from_in_business\n");
	# update cache relationships
	$var(src_callid)="";
	if(is_present_hf("X-SRC-CALL-ID")){
		$var(src_callid)=$(hdr(X-SRC-CALL-ID));
		store_callid("$ci", "$var(src_callid)");
		store_callid("$var(src_callid)", "$ci");
		remove_hf("X-SRC-CALL-ID");
	}
	# delete maxptime
	if(subst_body("/^a=maxptime.*[\n]?//gi")){
		xlog("L_DBG", ">>>DBG: Removed maxptime line from SDP body\n");
	}else{
		xlog("L_DBG", ">>>DBG: No maxptime line in SDP body\n");
	}
	# update du <-- loose_route
	# service-type
	$var(service_type)="";
	if(is_present_hf("X-SRC-SERVICE-TYPE")){
		$var(service_type)=$(hdr(X-SRC-SERVICE-TYPE));
		remove_hf("X-SRC-SERVICE-TYPE");
	}
	xlog("L_DBG", ">>>DBG: Service type is [$var(service_type)]\n");
	# 100rel
	if(is_present_hf("Require")){
		if(subst('/^(Require:.*)100rel\s*,(.*)$/\1\2/i')){
			xlog("L_INFO", ">>>INFO: Removed 100rel from Require(1)\n");
		}else if(subst('/^(),\s*100rel(.*)$/\1\2/i')){
			xlog("L_INFO", ">>>INFO: Removed 100rel from Require(2)\n");
		}else if(search('^Require:.*100rel.*$')){
			remove_hf("Require");
			xlog("L_INFO", ">>>INFO: Removed 100rel from Require(3)\n");
		}else{
			xlog("L_INFO", ">>>INFO: No matched 100rel...\n");
		}
	}
	# resume pani
	$var(r_pani)="";
	fetch_info("$var(src_callid)", "invite", "pani", "$var(r_pani)");
	xlog("L_DBG", ">>>DBG: Fetched pani is [$var(r_pani)]\n");
	if(is_present_hf("P-Access-Network-Info")){
		remove_hf("P-Access-Network-Info");
	}
	append_hf("P-Access-Network-Info: $var(r_pani)\r\n");

	# YLY block 
	$var(inroute)="";
	if($var(service_type)=="yly"){
		# resume route
		fetch_info("$var(src_callid)", "invite", "route", "$var(inroute)");
		$var(inroute_cnt)=$(var(inroute){s.select,-1,:});
		$var(inroute_cnt)=$(var(inroute_cnt){s.int});
		if($var(inroute_cnt) > 0){
			while($var(inroute_cnt) > 0){
				$var(inroute_cnt)=$var(inroute_cnt)-1;
				$var(inroute_index)=$(var(inroute){s.select,$var(inroute_cnt),:});
				$var(inroute_index)=$(var(inroute_index){s.decode.hexa});
				xlog("L_DBG", ">>>DBG: Fetched route = [$var(inroute_index)]\n");
				append_hf("Route: $var(inroute_index)\r\n");
			}
		}
	}

	# resume Request-Uri
	if($var(service_type)=="yly"){
		$var(r_user)="";
		fetch_info("$var(src_callid)", "invite", "ruser", "$var(r_user)");
		if($var(r_user)!=""){
			#$ru="tel"+$var(r_user);
			$ru="sip:"+$var(r_user)+"@"+"192.168.20.32"; #Just for test
		}else{
			xlog("L_ERR", ">>>ERR: Failed to fetch Request-User\n");
		}
	}else{
		$var(changed_rU)=0;
		$var(rU_new)=$rU;
		if(!($var(rU_new)=~"^\+86.*")){
			$var(changed_rU)=1;
			xlog("L_DBG", ">>>DBG: Request User headered with no [+86]\n");
			if(!($var(rU_new)=~"^0?1[3456789][0-9]{9}$")){
				if($var(rU_new)=~"^0[1-9]*"){
					$var(rU_new)=$(var(rU_new){s.substr,1,0});
				}
			}
			$var(rU_new)="+86"+$var(rU_new);
			xlog("L_DBG", ">>>DBG: Fixed Request-User is [$var(rU_new)]\n");
		}
		if(($ru=~"^sip:.*@.*") || ($var(changed_rU)==1)){
			$ru="tel:"+$var(rU_new);
		}
		xlog("L_DBG", ">>>DBG: Fixed Request Uri is [$var(ru)]\n");
	}

	# resume From-Uri/To-Uri/Pai
	if($var(service_type)=="yly"){
		# From-Uri
		$var(r_from)="";
		fetch_info("$var(src_callid)", "invite", "from", "$var(r_from)");
		#$var(r_from)=$(var(r_from){s.decode.hexa});
		xlog("L_DBG", ">>>DBG: Fetched from-uri is [$var(r_from)]\n");
		uac_replace_from("", "$var(r_from)");
		# To-Uri
		$var(r_to)="";
		fetch_info("$var(src_callid)", "invite", "to", "$var(r_to)");
		#$var(r_to)=$(var(r_to){s.decode.hexa});
		xlog("L_DBG", ">>>DBG: Fetched to-uri is [$var(r_to)]\n");
		uac_replace_to("", "$var(r_to)");
		# Pai
		$var(r_pai)="";
		fetch_info("$var(src_callid)", "invite", "api", "$var(r_pai)");
		#$var(r_pai)=$(var(r_pai){s.decode.hexa});
		xlog("L_DBG", ">>>DBG: Fetched pai is [$var(r_pai)]\n");
		append_hf("P-Asserted-Identity: $var(r_pai)\r\n");
	}else{
		# Fixed From-User
		$var(fU_new)=$fU;
		$var(changed_fU)=0;
		if(!($var(fU_new)=~"^\+86.*")){
			$var(changed_fU)=1;
			if(!($var(fU_new)=~"^0?1[3456789][0-9]{9}$")){
				if($var(fU_new)=~"^0.*"){
					$var(fU_new)=$(var(fU_new){s.substr,1,0});
				}
			}
			$var(fU_new)="+86"+$var(fU_new);
		}
		# From-Uri
		if(is_present_hf("X-FROM-DOMAIN")){
			$var(x_from_domain)=$(hdr(X-FROM-DOMAIN));
			$var(x_from_domain_len)=$(var(x_from_domain){s.len});
			xlog("L_DBG", ">>>X-FROM-DOMAIN [$var(x_from_domain)] with [$var(x_from_domain_len)]\n");
			if($var(x_from_domain_len) > 0){
				$var(fu_new)="sip:"+$var(fU_new)+"@"+$var(x_from_domain);
				uac_replace_from("", "$var(fu_new)");
			}
			remove_hf("X-FROM-DOMAIN");
		}else if($var(changed_fU)==1){
			xlog("L_WARN", ">>>WARNING: No from-domain\n");
			$var(fu_new)="sip:"+$var(fU_new)+"@"+$(fu{uri.host});
			uac_replace_from("", "$var(fu_new)");
		}
	}

	# Header fields clearing
	if(is_present_hf("X-SRC-CALL-ID")){
		remove_hf("X-SRC-CALL-ID");
	}
	if(is_present_hf("X-SRC-BYPASS")){
		remove_hf("X-SRC-BYPASS");
	}
	if(is_present_hf("X-SRC-SERVICE-TYPE")){
		remove_hf("X-SRC-SERVICE-TYPE");
	}
	if(is_present_hf("X-SRC-LOG-TRACER")){
		remove_hf("X-SRC-LOG-TRACER");
	}
	if(is_present_hf("X-RECORD-SRCDST")){
		remove_hf("X-RECORD-SRCDST");
	}
	if(is_present_hf("X-RECORD-SRCIP")){
		remove_hf("X-RECORD-SRCIP");
	}
	if(is_present_hf("X-FROM-DOMAIN")){
		remove_hf("X-FROM-DOMAIN");
	}
}

#onreply_route{
	#sip_capture();
#}

#branch_route[per_branch_ops] {
#	xlog("new branch at $ru\n");
#}
#
#
#onreply_route[handle_nat] {
#	xlog("incoming reply\n");
#}
#
#
#failure_route[missed_call] {
#	# zhou-- >>>>
#	#if (t_was_cancelled()) {
#	#	exit;
#	#}
#	# zhou-- <<<<
#
#	# uncomment the following lines if you want to block client 
#	# redirect based on 3xx replies.
#	##if (t_check_status("3[0-9][0-9]")) {
#	##t_reply("404","Not found");
#	##	exit;
#	##}
#
#	
#}



